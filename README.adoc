ip2unix(1)
==========
ifndef::manmanual[]
:doctitle: IP2Unix - Turn IP sockets into Unix domain sockets
endif::[]
:revdate: November 2018
ifndef::manmanual[]
:toc: macro
:numbered:
:toc-title:
endif::[]

ifdef::manmanual[]
== Name

ip2unix - Turn IP sockets into Unix domain sockets

== Synopsis

[verse]
*ip2unix* [*-v*...] [*-p*] *-f* 'RULES_FILE' 'PROGRAM' ['ARGS'...]
*ip2unix* [*-v*...] [*-p*] *-F* 'RULES_DATA' 'PROGRAM' ['ARGS'...]
*ip2unix* [*-v*...] [*-p*] *-r* 'RULE' [*-r* 'RULE']... 'PROGRAM' ['ARGS'...]
*ip2unix* [*-v*...] [*-p*] *-c* *-f* 'RULES_FILE'
*ip2unix* [*-v*...] [*-p*] *-c* *-F* 'RULES_DATA'
*ip2unix* [*-v*...] [*-p*] *-c* *-r* 'RULE' [*-r* 'RULE']...
*ip2unix* *-h*
*ip2unix* *--version*

endif::[]

ifndef::manmanual[]
:man_url: http://man7.org/linux/man-pages
:sysdman_url: https://www.freedesktop.org/software/systemd/man

:1: {man_url}/man8/ld.so.8.html#ENVIRONMENT
:2: {man_url}/man2/accept.2.html
:3: {sysdman_url}/systemd.socket.html
:4: pass:attributes,quotes[{3}#FileDescriptorName=]

:LD_PRELOAD: pass:attributes,quotes[*LD_PRELOAD* ({1}[*ld.so*(8)])]
:syscall_accept: pass:attributes,quotes[{2}[*accept*(2)]]
:systemd_socket: pass:attributes,quotes[{3}[*systemd.socket*(5)]]
:fdname: pass:attributes,quotes[{4}[FileDescriptorName]]
:rulespec: <<Rule specification>>
:rulefileformat: <<Rule file format>>
:copy: (C) 2018 aszlig
endif::[]
ifdef::manmanual[]
:LD_PRELOAD: pass:quotes[*LD_PRELOAD* (see *ld.so*(8))]
:syscall_accept: pass:quotes[*accept*(2)]
:systemd_socket: pass:quotes[*systemd.socket*(5)]
:fdname: pass:quotes[FileDescriptorName (see *systemd.socket*(5))]
:rulespec: pass:quotes[*RULE SPECIFICATION*]
:rulefileformat: pass:quotes[*RULE FILE FORMAT*]
:copy: \(C) 2018 aszlig
endif::[]

:lgpl_url: https://www.gnu.org/licenses/lgpl-3.0.html

ifndef::without-systemd[:systemd_comma: ,]
ifdef::without-systemd[:systemd_comma:]

ifndef::without-systemd[:systemd_backslash: \]
ifdef::without-systemd[:systemd_backslash:]

ifdef::manmanual[]
== Description
endif::manmanual[]

ifdef::env-github[]
:hydra_url: https://headcounter.org/hydra
:badge_job: pass:attributes[{hydra_url}/job/ip2unix/master/badge]
:badge_url: pass:attributes[{badge_job}/latest-finished/download/1/status.svg]
:latest_eval: pass:attributes[{hydra_url}/jobset/ip2unix/master]
image:https://builtwithnix.org/badge.svg["built with nix",
                                         link="https://builtwithnix.org/"]
image:{badge_url}["build status", link="{latest_eval}"]
endif::env-github[]

Executes a program and converts IP to Unix domain sockets at runtime based on a
list of rules, either given via short command line options (see {rulespec}) or
via a file with a list of rules (see {rulefileformat}). The first matching rule
causes *ip2unix* to replace the current IP socket with a Unix domain socket
based on the options given. For example if a <<rule-socket-path,*path*>>
is specified, the Unix domain socket will bind or listen to the given path.

ifndef::manmanual[]

[discrete]
== Problem statement

A lot of programs are designed to only work with IP sockets, however very few
of them allow to communicate via Unix domain sockets. Unix domain sockets
usually are just files, so standard Unix file permissions apply to them.

IP sockets also have the disadvantage that other programs on the same host are
able to connect to them, unless you use complicated netfilter rules or network
namespaces.

So if you either have a multi-user system or just want to separate privileges,
Unix domain sockets are a good way to achieve that.

Another very common use case in nowadays systems is when you're using systemd
and want to use socket units to allow parallel startup of services.

[discrete]
== Short example

Let's say you have a small HTTP server you want to make available behind a HTTP
reverse proxy.

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r path=/run/my-http-server.socket my-http-server
---------------------------------------------------------------------

This will simply convert all IP sockets to the Unix domain socket available at
`/run/my-http-server.socket`. If you use a web server like
https://nginx.org/[nginx], you can use the following directive to connect to
that socket:

[source,nginx]
---------------------------------------------------------------------
proxy_pass http://unix:/run/my-http-server.socket;
---------------------------------------------------------------------

More examples can be found further below in section <<Examples>>.

A short summary of all the options is available via `ip2unix --help` or
`man ip2unix` if you want to see all the details and options available.

ifndef::manmanual[]
[discrete]
= Table of Contents

toc::[]
endif::[]

== Build from source

=== Requirements

* https://mesonbuild.com/[Meson], at least version 0.46.0.
* https://ninja-build.org/[Ninja], at least version 1.5.
* https://github.com/jbeder/yaml-cpp[yaml-cpp], at least version 0.5.0
* {cpp} compiler supporting {cpp}17 (https://gcc.gnu.org/[GNU G++] version 7.0
  onwards).
* https://www.python.org/[Python] 3, at least version 3.6 is needed for running
  the integration tests.

.Optional dependencies:
* http://asciidoc.org/[AsciiDoc] or https://asciidoctor.org/[Asciidoctor] for
  generating the manpage. The former is recommended as it generates a better
  manpage and also provides validation.
* https://pytest.org/[pytest] for running automated tests.
* {sysdman_url}/systemd-socket-activate.html[systemd-socket-activate]
  helper to run test cases specific to systemd socket activation support.

=== Cloning the repository

The source code can be fetched via https://git-scm.com/[Git] using the
following command:

[source,sh-session]
---------------------------------------------------------------------
$ git clone https://github.com/nixcloud/ip2unix.git
---------------------------------------------------------------------

You will get an `ip2unix` directory inside your current working directory. All
of the following steps are to be performed inside this `ip2unix` directory.

==== Using the Nix package manager

This is the easiest and recommended way to compile it from source and it should
work on any distribution.

If you are not running https://nixos.org/[NixOS] you can install
https://nixos.org/nix/[Nix] via the following command:

[source,sh-session]
---------------------------------------------------------------------
$ curl https://nixos.org/nix/install | sh
---------------------------------------------------------------------

In order to build *ip2unix* issue the following command from the top of the
source tree:

[source,sh-session]
---------------------------------------------------------------------
$ nix-build
---------------------------------------------------------------------

This takes care of fetching the dependencies, building and running the test
suite. The resulting command can now be found in `result/bin/ip2unix`.

If you want to add the package to your user environment, you can install it
using the command:

[source,sh-session]
---------------------------------------------------------------------
$ nix-env -f . -i
---------------------------------------------------------------------

==== Debian and derivatives

Fetching the requirements on Debian 9 can be tricky because only GCC version 6
is available, so
<<Using the Nix package manager,using the Nix package manager>> is recommended
here as it does not interfere with the rest of the system.

However if you still want to build it on Debian 9, you can install `g++-7` from
testing. Please be aware that mixing packages from `testing` might update
unrelated packages and might make your system less stable.

In addition to the C++ compiler, the version of Meson on Debian 9 is too old as
well. However it can be installed from the Python Package Index using `pip`:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install python3-pip
$ pip3 install meson
---------------------------------------------------------------------

After you are done getting a newer Meson and C++ compiler, you can use the
following command to install the other required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install ninja-build pkg-config libyaml-cpp-dev
---------------------------------------------------------------------

If you want to have a manpage and support for systemd socket activation:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install asciidoctor libsystemd-dev
---------------------------------------------------------------------

In case you want to run the test suite, pytest is required:

[source,sh-session]
---------------------------------------------------------------------
$ sudo apt-get install python3-pytest
---------------------------------------------------------------------

==== RPM-based distributions

On Fedora 29, all of the dependencies are recent enough, so in order to install
the required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install meson gcc-c++ yaml-cpp-devel
---------------------------------------------------------------------

The optional dependencies for the manpage and for systemd socket activation:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install asciidoctor systemd-devel
---------------------------------------------------------------------

If you want to run the test suite:

[source,sh-session]
---------------------------------------------------------------------
$ sudo yum install python3-pytest
---------------------------------------------------------------------

==== Arch Linux and derivatives

To install the required dependencies:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S yaml-cpp meson gcc pkg-config
---------------------------------------------------------------------

If you want to have the manpage:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S asciidoctor
---------------------------------------------------------------------

In case you want to run the test suite:

[source,sh-session]
---------------------------------------------------------------------
$ sudo pacman -S python-pytest
---------------------------------------------------------------------

=== Building

[source,sh-session]
---------------------------------------------------------------------
$ meson build
---------------------------------------------------------------------

If you want to specify a different compiler executable, eg. `g++-7`:

[source,sh-session]
---------------------------------------------------------------------
$ CXX=g++-7 meson build
---------------------------------------------------------------------

Compile:

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build
---------------------------------------------------------------------

The executable is then placed in `build/ip2unix`, so to show the usage:

[source,sh-session]
---------------------------------------------------------------------
$ build/ip2unix --help
---------------------------------------------------------------------

=== Installation

To install *ip2unix*, run the following command:

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build install
---------------------------------------------------------------------

By default, this will install *ip2unix* in `/usr/local/bin/ip2unix`.

=== Running tests

[source,sh-session]
---------------------------------------------------------------------
$ ninja -C build test
---------------------------------------------------------------------

endif::[]

ifdef::manmanual[]

== Options

*-c, --check*::
  This is to validate whether the rule file is correct and the program
  just prints all validation errors to stderr and exits with exit code `0`
  if validation was successful and `1` if not.

*-h, --help*::
  Show command line usage and exit.

*--version*::
  Show version information and exit.

*-p, --print*::
  Print out the rules that are in effect in a tabular format. If you do not
  want to run the 'PROGRAM', you can use the *-c* option to exit after
  printing the rules.

*-r, --rule*='RULE'::
  A single rule for one particular socket to match, can be used several times
  to specify a set of rules similar to the sequence of the rule file.

*-f, --rules-file*='RULES_FILE'::
  Specifies a YAML or JSON file consisting of a sequence of rules.

*-F, --rules-data*='RULES_DATA'::
  Similar to *-f*, but instead of specifying a file, directly pass the contents
  as an argument.

*-v, --verbose*::
  Increases the level of verbosity, according to the following table:

  'FATAL' (default);;
    Only prints fatal errors that causes the program to terminate.
  'ERROR' (*-v*);;
    Also print errors that are recoverable.
  'WARNING' (*-vv*);;
    Also print messages that might indicate possible problems.
  'INFO' (*-vvv*);;
    Also print informational messages about *ip2unix* behavior.
  'DEBUG' (*-vvvv*);;
    Also show messages about *ip2unix* internals along with source information.
  'TRACE' (*-vvvvv*);;
    Print every log message possible.

endif::[]

== Rule specification

Arguments specified via *-r* contain a comma-separated list of either flags or
options. If a value contains a comma (`,`), it has to be escaped using a
backslash (`\`) character. If you want to have a verbatim backslash character
just use two consecutive backslashes instead.

The following flags are available:

*in* | *out*::
  Corresponds to the <<rule-opt-direction,*direction*>> rule file option and
  if it is not set, both incoming and outgoing connections are matched.

*tcp* | *udp*::
  Either match TCP or UDP sockets or both if none of these flags are set
  (<<rule-opt-type,*type*>> rule file option).

ifndef::without-systemd[]
*systemd*[='FD_NAME']::
  Enable systemd socket activation
  (see <<rule-opt-socket-activation,*socketActivation*>> below), optionally
  specifying a file descriptior name (<<rule-opt-fdname,*fdName*>>).
endif::[]

*reject*[='ERRNO']::
  Reject calls to *connect* and *bind* with `EACCES` by default or the 'ERRNO'
  specified either via name or as an integer.

*blackhole*::
  When binding the socket, use a temporary file system path and *unlink* it
  shortly after the *bind*. This is a way to deactivate a specific socket
  without the application noticing.

*ignore*::
  Don't handle the socket matching this rule, see the corresponding rule file
  option <<rule-opt-ignore,*ignore>>.

These options are available:

*addr*[*ess*]='ADDRESS'::
  Optional, specifies an IPv4 or IPv6 address, see
  <<rule-opt-address,*address*>> rule file option.

*port*='PORT'[-'PORT_END']::
  Optional, specifies a port to match, see the <<rule-opt-port,*port*>> and
  optionally the <<rule-opt-port-end,*portEnd*>> rule file option if you want
  to specify a port range.

*path*='SOCKET_PATH'::
  The path to the socket file to either bind or connect to, which is similar to
  the <<rule-socket-path,*path*>> rule file option but also allows
  relative paths.

== Rule file format

The rule file (specified via *-f* is a YAML file (or JSON, as it is a subset of
YAML), consisting of an array of objects.

Each object consists of keys/values which define which IP sockets to match
and which Unix domain sockets to assign them to.

=== Rule file options

[[rule-opt-direction]]*direction*::

Whether this rule applies to a server-side socket (`incoming`), a client-side
socket (`outgoing`) or both if not defined.

[[rule-opt-type]]*type*::

Specifies the IP type, which currently is either `tcp` for TCP sockets, `udp`
for UDP sockets or if it is not defined it matches both UDP and TCP sockets.

[[rule-opt-address]]*address*::

The IP address to match, which can be either an IPv4 or an IPv6 address.

[[rule-opt-port]]*port*::

UDP or TCP port number (depending on which <<rule-opt-type,*type*>> is set),
which for outgoing connections specifies the target port and for incomping
connections the port that the socket is bound to.

[[rule-opt-port-end]]*portEnd*::

Optionally specifies the end of a port range to match, so for example if
<<rule-opt-port,*port*>> is `2000` and *portEnd* is `3000` all ports in the
range from 2000 to 3000 (inclusive) are matched.

[[rule-socket-path]]*path*::

The path to the socket file to use for either binding or connecting to
depending on whether the above options apply for a particular IP socket.
+
Placeholders are allowed here and those are substituted accordingly:
+
[horizontal]
*%p*;; port number
*%a*;; IP address or `unknown`
*%t*;; socket type (`tcp`, `udp` or `unknown`)
*%%*;; verbatim `%`

ifndef::without-systemd[]
[[rule-opt-socket-activation]]*socketActivation*::
ifndef::manmanual[]
If *ip2unix* is compiled with systemd support, whether to use socket activation
endif::[]
ifdef::manmanual[]
Whether to use systemd socket activation
endif::[]
instead of a <<rule-socket-path,*path*>>. See {systemd_socket}.

[[rule-opt-fdname]]*fdName*::
An optional file descriptor name for socket activation which can be used to
distinguish between several socket units. This corresponds to the {fdname}
systemd socket option.
endif::[]

[[rule-reject]]*reject*::
  If true, reject calls to *connect* and *bind* with `EACCES`.

*rejectError*::
  Specifies an alternative error code to be returned by
  <<rule-reject,*reject*>> instead of `EACCES`. This can be either a string
  such as `EADDRINUSE` (case does not matter) or an integer.

*blackhole*::
  If true, a temporary file system path is used and unlinked shortly
  thereafter, so the socket is effectively deactivated in a way that the
  application should not recognize. Only valid if
  <<rule-opt-direction,*direction*>> is `incoming`.

[[rule-opt-ignore]]*ignore*::
  Prevents a socket from being converted to a Unix domain socket if this is
  true. This is useful to exempt specific sockets from being matched when
  another rule matches a broad scope.

== Examples

=== Simple HTTP client/server

On the server side with the rule file `rules-server.yaml`:

[source,yaml]
---------------------------------------------------------------------
- direction: incoming
  path: /tmp/test.socket
---------------------------------------------------------------------

The following command spawns a small test web server listening on
`/tmp/test.socket`:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-server.yaml python3 -m http.server 8000
---------------------------------------------------------------------

The same can be achieved using *-r*:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r in,path=/tmp/test.socket python3 -m http.server 8000
---------------------------------------------------------------------

On the client side with `rules-client.yaml`:

[source,yaml]
---------------------------------------------------------------------
- direction: outgoing
  path: /tmp/test.socket
---------------------------------------------------------------------

This connects to the test server listening on `/tmp/test.socket`
and should show the directory listing:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -f rules-client.yaml curl http://1.2.3.4/
---------------------------------------------------------------------

With the *-r* option:

[source,sh-session]
---------------------------------------------------------------------
$ ip2unix -r out,path=/tmp/test.socket curl http://1.2.3.4/
---------------------------------------------------------------------

=== More complicated example

[source,yaml]
--------------------------------------------
- direction: outgoing                 ## <1>
  port: 53
  ignore: true
- direction: outgoing                 ## <2>
  type: tcp
  path: /run/some.socket
- direction: incoming                 ## <3>
  address: 1.2.3.4
  path: /run/another.socket
- direction: incoming                 ## <4>
  port: 80
  address: abcd::1
  blackhole: true
- direction: incoming                 ## <5>
  port: 80
  reject: true
  rejectError: EADDRINUSE
ifndef::without-systemd[]
- direction: incoming                 ## <6>
  type: tcp
  port: 22
  socketActivation: true
  fdName: ssh
endif::without-systemd[]
--------------------------------------------

<1> All outgoing connections to port 53 (no matter if it's TCP or UDP) will not
    be converted into Unix domain sockets.
<2> This rule will redirect all TCP connections except to port 53 (see above)
    to use the Unix domain socket at `/run/some.socket`.
<3> Matches the socket that listens to any port on the IPv4 address `1.2.3.4`
    and instead binds it to the Unix domain socket at `/run/another.socket`.
<4> The application may bind to the IPv6 address `abcd::1` on port 80 but it
    will not receive any connections, because no socket path exists.
<5> Trying to bind to port 80 on addresses other than `abcd::1` will result
    in an `EADDRINUSE` error.
ifndef::without-systemd[]
<6> Will prevent the TCP socket that would listen on port 22 to not listen at
    all and instead use the systemd-provided file descriptor named `ssh` for
    operations like {syscall_accept}.
endif::[]

The same can be achieved solely using *-r* commandline arguments:

[source,sh-session]
[subs="attributes"]
----------------------------------------------------------------------------
$ ip2unix -r out,port=53,ignore \
          -r out,tcp,path=/run/some.socket \
          -r in,addr=1.2.3.4,path=/run/another.socket \
          -r in,port=80,reject=EADDRINUSE {systemd_backslash}
ifndef::without-systemd[]
          -r in,tcp,port=22,systemd=ssh
endif::without-systemd[]
----------------------------------------------------------------------------

== Limitations

* The program uses {LD_PRELOAD}, so it will only work with programs that are
dynamically linked against the C library. Using ip2unix on statically linked
executables or on executables that don't use the socket family functions of the
C library (like Go programs) will not work at the moment.

* If a client which is already using Unix *datagram* sockets sends packets via
*sendto* or *sendmsg* to a socket provided by *ip2unix* without binding first,
*ip2unix* is not able to identify the peer and will subsequently reject the
packet. This is not the case when using *ip2unix* itself on the the client side
and it also does not seem to be very common as the author so far did not find
such an application in the wild.
+
However, if this really is an issue to you, the recommended workaround is
either to use *ip2unix* to wrap the client (if it supports IP sockets) or fix
the server to natively use Unix domain sockets.

ifdef::manmanual[]

== Environment variables

*IP2UNIX_RULE_FILE*::
  When used in conjunction with {LD_PRELOAD}, this environment variable has to
  be set as well, specifying the absolute path to the rule file (see
  {rulefileformat} above).

== See also

*accept*(2),
*bind*(2),
*connect*(2),
*listen*(2),
*recvfrom*(2),
*recvmsg*(2),
*sendmsg*(2),
*sendto*(2),
*socket*(2),
*unix*(7){systemd_comma}
ifndef::without-systemd[*systemd.socket*(5)]

endif::[]

ifndef::manmanual[]

== Similar projects

https://cwrap.org/socket_wrapper.html[socket_wrapper]::

The goal is a different one here and its main use is testing. Instead of
using rules, *socket_wrapper* turns *all* of the IP sockets into Unix sockets
and uses a central directory to do the mapping.
+
Containing all Unix sockets into one directory has the nice effect that it is
easy to map *any* address/port combination to Unix sockets. While this is way
easier to implement than our approach it has the drawback that everything is
contained and no IP communication is possible anymore.

== Thanks

Special thanks to the https://nlnet.nl/[NLnet foundation] for sponsoring this
work.

endif::[]

ifdef::manmanual[]

== Author

Written by aszlig <aszlig@nix.build>

endif::[]

== Copyright

Copyright {copy}. License LGPLv3: GNU LGPL version 3 only
<{lgpl_url}>.

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
